#include "dsym.hxx"

//Ddiag konstruktor: dimenzio, elemszam, matrixok szamanak kitoltese, involucio
//matrix 0-ra definialasa, simplex_orbits 2 dimenzios simplex-pointerekbol allo tomb
//feltoltese. (Az elso "koord" a szamlalas kezdopontjanak valasztott szimplex
//sorszama+1, mert a 0-adikat szinte veletlenszeruen toltjuk ki; a masodik koord
//az adott kezdopont szerinti sorszama a megfelelo szimplexnek.)
//Megfelelo memoriacimek lefoglalasa.
Ddiag::Ddiag(int dim, int car):
  Base(dim,car),
  Rmx(dim,car),
  involucio(0)
{
  //az eredetivel egyutt az create_numberingasok szama
  simplex_orbits=new simplex**[car+1];	
  for (int k=0;k<car+1;k++) simplex_orbits[k]=new simplex*[car];
  for (int i=0;i<car;i++) simplex_orbits[0][i]=new simplex(dim,car,i);
}

//Ddiag destruktor: memoria felszabaditasa
Ddiag::~Ddiag(void) {
  for (int i=0;i<car;i++) delete simplex_orbits[0][i];
  for (int i=0;i<car;i++) delete[] simplex_orbits[i];
  delete[] simplex_orbits;
  delete dual;
  if(involucio) {
    for(int j=0;j<dim+1;j++){
      for(int k=0;k<*involucio[j][car];k++)
	delete[] involucio[j][k];
      delete involucio[j][car];
      delete[] involucio[j];
    }
    delete[] involucio;
  }
}

//Ddiag konstruktor (Ddiag parameterrel): letrehoz egy uj Ddiag objektumra mutato pointert, es egy uj
//objektumot is. 
//Atmasoljuk bele az osszes adatot az eredetibol, figyelve arra, hogy veletlenul
//se az eredeti egy simplexere mutato pointert mentsunk, hanem a sajaton belul a
//megfelelo sorszamut talaljuk meg.
Ddiag::Ddiag(Ddiag& olddiag) {
  dim=olddiag.dim;
  car=olddiag.car;
  for(int i=0;i<car;i++) for(int j=0;j<dim+1;j++) {
    //Ehhez kell tudni azonositani a simplex_orbitsat:
    int icsucsjszomszedja=olddiag.simplex_orbits[0][i]->szomszed[j]->sorszam[0];  
    //szomszedsagok beallitasa
    simplex_orbits[0][i]->szomszed[j]=simplex_orbits[0][icsucsjszomszedja];	
    //sorszamok
    simplex_orbits[0][i]->sorszam[0]=olddiag.simplex_orbits[0][i]->sorszam[0];	
  }
  for(int k=1;k<car+1;k++)
    for(int i=0;i<car;i++) {
      int icsucsksorszama=olddiag.simplex_orbits[k][i]->sorszam[0];
      simplex_orbits[k][i]=simplex_orbits[0][icsucsksorszama];
      simplex_orbits[k][i]->sorszam[k]=i;
    }
  invol_create(0);
  invol_create(1);
}

//Ddiag::create_numbering(i): i=1..car (0-val nem hivjuk meg, mert azt tetszolegesen
//toltjuk fel.)
//Az i. csucsbol(szimplexbol) indulva alkalmazzuk a sorszamozo algoritmust, es a
//simplex_orbits[i] listat feltoltjuk az algoritmus szerint.
//Az algoritmus roviden: D1,D2...Dr mar meg van szamozva. Dr-re alkalmazzuk a 0.
//operaciot, ha olyan csucsot(szimplexet) kapunk, ami meg nem szerepel, az a
//kovetkezo; aztan Dr-re alkalmazzuk az 1. operaciot (szinten, ha ujat kapunk,
//az lesz az r+1-edik); 2,3,...dim operacio Dr-re; 0,1,...dim operacio
//D(r-1)-re; 0..dim D(r-2)-re;...;0..dim D1-re
void Ddiag::create_numbering(int i) {
  int r=0;
  simplex** D;
  D=new simplex*[car];
  //azert i-1, mert a masodik koord 0..car-1, az elso pedig 0..car:
  D[0]=simplex_orbits[0][i-1];
  D[0]->sorszam[i]=0;
  while (r<car-1){
    r++;
    D[r]=NULL;
    if (simplex_find(D[r-1]->szomszed[0],r,D) == 0) {
      D[r]=D[r-1]->szomszed[0];
    }
    else if (simplex_find(D[r-1]->szomszed[1],r,D) == 0) {
      D[r]=D[r-1]->szomszed[1];
    }
    else 
      for (int k=r-1;k>=0;k--) {
	for (int j=0;j<dim+1;j++) {
	  if (simplex_find(D[k]->szomszed[j],r,D) == 0) {
	    D[r]=D[k]->szomszed[j];
	    break;
	  }
	}
	if (D[r] != NULL) {
	  break;
	}
      }
    D[r]->sorszam[i]=r;
  }
  for (r=0;r<car;r++) {
    simplex_orbits[i][r]=D[r];
  }
  delete[] D;
}

//simplex_find(...): mit a keresendo dolog, hossz a lista hossza, hol a lista elejere
//mutato pointer.
//Csak egy egyszeru segedfv keresesre.
int simplex_find(simplex* mit, int hossz, simplex** hol){
  for(int i=0;i<hossz;i++)
    if(mit==hol[i])
      return 1;
  return 0;
}

//kisebb(...): Adott egyik es masik D-szimbolum, ev es mv kezdo
//simplex_orbitskal(szimplexekkel) Erre alkalmazzuk a rendezesi algoritmusunkat, aminek
//alapja a tavolsag ket csucs kozott: az egyik csucsbol vett szamozas szerinti
//sorszama a masik csucsnak. Ezutan ugy rendezunk, hogy vesszuk az operaciokat
//csokkeno sorrendben majd a simplex_orbitsat novekvoben es megvizsgaljuk, hogy az
//adott operaciot alkalmazva a csucsra, milyen tavolsagra kerulunk a csucstol.
//Az elso hely, ahol a ket szimbolum kulonbozik, dont: amelyik kisebb, az a
//szimbolun a kisebb (azaz lexikografikusan rendezunk.)
int kisebb(Ddiag* egyik,int ev,Ddiag* masik,int mv){
  if (egyik->dim != masik->dim) return (masik->dim > egyik->dim) ? 1: -1;
  if (egyik->car != masik->car) return (masik->car > egyik->car) ? 1: -1;
  int dim=egyik->dim;
  int car=egyik->car;
  simplex** egyiks=egyik->simplex_orbits[ev];
  simplex** masiks=masik->simplex_orbits[mv];
  for (int j=dim;j>=0;j--)
    for (int i=0;i<car-1;i++){
      if (egyiks[i]->szomszed[j]->sorszam[ev] != 
	  masiks[i]->szomszed[j]->sorszam[mv])
      {
	return (masiks[i]->szomszed[j]->sorszam[mv] > 
	    egyiks[i]->szomszed[j]->sorszam[ev]) ? 1 : -1;
      }
    }
  return 0;
}

//Ddiag::generate_dual, check_dual: dual valtozo feltoltese. Felcsereljuk az i. es a (dim-i).
//operaciokat minden i-re. Visszateresi ertek: -1, ha a dualis kisebb, 0 ha
//egyenloek, 1 ha a dualis nagyobb.
void Ddiag::generate_dual(void) {
  if(!dual) dual=new Ddiag(dim,car);
  for(int i=0;i<car;i++) for(int j=0;j<dim+1;j++) {
    int icsucsjszomszedja=simplex_orbits[0][i]->szomszed[j]->sorszam[0];
    //felcsereljuk az elek szineit... (dim-j)
    dual->simplex_orbits[0][i]->szomszed[dim-j]=dual->simplex_orbits[0][icsucsjszomszedja];
    dual->simplex_orbits[0][i]->sorszam[0]=i; 
  }
  create_numbering(1);
  dual->create_numbering(1);
}

int Ddiag::check_dual(void) {
  return kisebb(dual,1,this,1);
}

//Ddiag::check_numberings: az osszes csucsbol indulva megnezzuk, hogy talalunk-e
//kisebbet a D-szimbolumunknal. Az egyformakat szamoljuk.
int Ddiag::check_numberings(void) {
  int k;
  symmetric=1;
  create_numbering(1);
  if(kisebb(this,0,this,1)!=0) return 1;
  for (int i=2;i<car+1;i++) {
    create_numbering(i);
    k=kisebb(this,i,this,1);
    if (k==1) {
      return 1;
    }
    else if (k==0) symmetric++;
  }
  if (symmetric>1 && symmetric<car) return 0;  //Miert kell a car-nal kisebbnek lennie?
  else return -1;
}

//Ddiag::connected: Egymas utan alkalmazott szelessegi bejarasokkal
//megszamoljuk, hogy az elhagy valtozo altal jelzett operaciot elhagyva hany
//reszre esik szet a multigraf. (elhagy=-1 eseten pl nem hagyunk el valtozot.)
//A nemelerheto listat toltjuk fel az elejen, es torolgetjuk belole az elsot,
//annak szomszedait, majd annak szomszedait... ameddig lehet, ha elfogyott,
//veszunk egy uj elso elemet, noveljuk eggyel a komponensek szamat, es kezdjuk
//elolrol, amig nem ures a nemelerheto lista.
int Ddiag::connected(int elhagy) {
  list<int> nemelerheto,utolso,uj;
  list<int>::iterator hanyadik;
  int hanydarab=0;

  for(int i=0;i<car;i++) nemelerheto.push_back(i);	//nemelerheto feltoltese
  while (!nemelerheto.empty()) {
    uj.clear();
    uj.push_back(*nemelerheto.begin());
    hanydarab++;
    while (!uj.empty()) {
      utolso.clear();
      for ( list<int>::iterator p = uj.begin(); p != uj.end(); ++p ) 
	utolso.push_back(*p);	//uj->utolso
      uj.clear();
      for (list<int>::iterator r = utolso.begin(  ); r != utolso.end(  ); ++r ){
	//utolso szomszedai metszet nemelerheto->uj
	for (int j=0;j<dim+1;j++) {
	  if ( j!=elhagy ){
	    hanyadik=find(nemelerheto.begin(),nemelerheto.end(),
		simplex_orbits[0][*r]->szomszed[j]->sorszam[0]);
	    if (hanyadik != nemelerheto.end() ) {
	      uj.push_back(*hanyadik);
	      //talalt nemelerhetoek torlese
	      nemelerheto.erase(hanyadik);
	    }
	  }
	}
      }
    }
  }
  return hanydarab;
}

//Ddiag::generate_r, check_r: Ellenorizzuk igaz-e, hogy barmely ket nem szomszedos (es nem
//azonos) operaciot 4-szer egymas utan alkalmazva visszajutunk a kiindulasi
//pontba. Es feltoltjuk a matrixokban az informaciot (a szabad parameterekkel
//meg nem foglalkozunk, csak beirjuk oket a matrixba.) 0-t adunk vissza, ha nem
//teljesul a fenti feltetel, 1-et, ha teljesul.
void Ddiag::generate_r(void){
  for (int r=0;r<car;r++) {
    for (int i=0;i<dim+1;i++)
      for (int j=0;j<dim+1;j++){
	int u=1;
	simplex* csucs=simplex_orbits[1][r];
	while (csucs->szomszed[i]->szomszed[j] != simplex_orbits[1][r]){
	  u++;
	  csucs=csucs->szomszed[i]->szomszed[j];
	}
	Rmx->set(r,i,j);
      }
  }
}

int Ddiag::check_r(void) {
  for (int r=0;r<car;r++)
    for (int i=0;i<dim-1;i++)
      for (int i1=i+2;i1<dim+1;i1++)
	if(Rmx->get(r,i,j) > 2)
	  return 0;
  return 1;
}


//Ddiag::check_all: Az elobb definialt ellenorzesek lefuttatasa.
int Ddiag::check_all(void) {
  if (check_connected(-1) > 1) return 1; //csak az osszefuggoek erdekesek
  if (check_numberings()==1) return 1; 
  if (!check_r()) return 1;
  return -1;
}

//Ddiag::create_edge(...): A szin, honnan, hova valtozoharmas altal leirt elt adja
//hozza a multigrafhoz, ha ezt meg lehet tenni, azaz egyik csucsanal sincs meg
//definialva a szin altal leirt szomszedsagi operacio.
int Ddiag::create_edge(int szin, int honnan, int hova) {
  if (szin<0 || szin>dim || honnan<0 || honnan >=car || hova<0 || hova>=car ) 
    return 0;
  if (simplex_orbits[0][honnan]->szomszed[szin] != simplex_orbits[0][honnan] ||
      simplex_orbits[0][hova]->szomszed[szin] != simplex_orbits[0][hova]) {
    //cout << "Nem tudok elt hozzaadni, mert nincs torolve az elozo" << endl;
    return 0;
  }
  simplex_orbits[0][honnan]->szomszed[szin]=simplex_orbits[0][hova];
  simplex_orbits[0][hova]->szomszed[szin]=simplex_orbits[0][honnan];
  return 1;
}

//Ddiag::remove_edge: Torli a megfelelo elt, ha ez ertelmesen megteheto.
void Ddiag::remove_edge(int szin, int honnan, int hova) {
  if (szin<0 || szin>dim || honnan<0 || honnan >=car || hova<0 || hova>=car ) 
    return;
  if (simplex_orbits[0][honnan]->szomszed[szin] != simplex_orbits[0][hova]) {
    cerr << "Nincs el (szin, honnan, hova): " <<szin<<" "<<honnan<<" "<<hova
						<< endl;
    return;
  }
  simplex_orbits[0][honnan]->szomszed[szin]=simplex_orbits[0][honnan];
  simplex_orbits[0][hova]->szomszed[szin]=simplex_orbits[0][hova];
}


//Ddiag::invol_create: involuciokent egyszeruen abrazolhato a multigraf konzolon.
//Ezt hozzuk itt letre. Csak az elore elek kellenek nekunk 
//(kisebb sorszam->nagyobb sorszam)
void Ddiag::invol_create(int var) {
  if(involucio)
    for (int j=0;j<dim+1;j++) {
      for (int d=0;d<*involucio[j][car];d++)
	delete[] involucio[j][d];
      delete involucio[j][car];
      delete[] involucio[j];
    }
  involucio=new int**[dim+1];
  for (int j=0;j<dim+1;j++) {
    involucio[j]=new int*[car+1];
    involucio[j][car]=new int;	//*involucio[j][car] az aktualis hossz
    *involucio[j][car]=0;
    for (int i=0;i<car;i++) {
      int kell=1;
      int masik=simplex_orbits[var][i]->szomszed[j]->sorszam[var];
      if(masik==i) continue;
      for(int k=0;k<*involucio[j][car];k++){
	if (involucio[j][k][1]==i ) {
	  kell=0;
	  break;
	}
      }
      if (kell==1) {
	involucio[j][*involucio[j][car]]=new int[2];
	involucio[j][*involucio[j][car]][0]=i;
	involucio[j][*involucio[j][car]][1]=masik;
	++(*involucio[j][car]);
      }
    }
  }
}


//Ddiag::print: A fenti involucio konzolra irasa, illetve az egyes operaciok 
//elhagyasaval hany darabra esik a multigraf.
void Ddiag::print(int var) {
  invol_create(var);
  cout << "=========================" << endl;
  for (int j=0;j<dim+1;j++) {
    for(int k=0;k<*involucio[j][car];k++){
      cout << "[" << involucio[j][k][0]+1 << "," << involucio[j][k][1]+1 <<"] ";
    }
    cout << endl;
  }
  cout << "Number of " << dim-1 << " dimensional components: ";
  cout << "("<<osszefuggo(0);
  for (int i=1;i<dim+1;i++) cout <<","<<osszefuggo(i);
  cout << ")"<<endl;
}
